[
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "field",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "torch",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "torch",
        "description": "torch",
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "amp",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "torch.nn",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "torch.nn",
        "description": "torch.nn",
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "resnet50",
        "importPath": "torchvision.models",
        "description": "torchvision.models",
        "isExtraImport": true,
        "detail": "torchvision.models",
        "documentation": {}
    },
    {
        "label": "_veg_indices",
        "importPath": "data_util",
        "description": "data_util",
        "isExtraImport": true,
        "detail": "data_util",
        "documentation": {}
    },
    {
        "label": "_veg_indices",
        "importPath": "data_util",
        "description": "data_util",
        "isExtraImport": true,
        "detail": "data_util",
        "documentation": {}
    },
    {
        "label": "BigEarthNetv2_0_ImageClassifier",
        "importPath": "reben_publication.BigEarthNetv2_0_ImageClassifier",
        "description": "reben_publication.BigEarthNetv2_0_ImageClassifier",
        "isExtraImport": true,
        "detail": "reben_publication.BigEarthNetv2_0_ImageClassifier",
        "documentation": {}
    },
    {
        "label": "BigEarthNetv2_0_ImageClassifier",
        "importPath": "reben_publication.BigEarthNetv2_0_ImageClassifier",
        "description": "reben_publication.BigEarthNetv2_0_ImageClassifier",
        "isExtraImport": true,
        "detail": "reben_publication.BigEarthNetv2_0_ImageClassifier",
        "documentation": {}
    },
    {
        "label": "lightning.pytorch",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "lightning.pytorch",
        "description": "lightning.pytorch",
        "detail": "lightning.pytorch",
        "documentation": {}
    },
    {
        "label": "torch.nn.functional",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "torch.nn.functional",
        "description": "torch.nn.functional",
        "detail": "torch.nn.functional",
        "documentation": {}
    },
    {
        "label": "ConfigILM",
        "importPath": "configilm",
        "description": "configilm",
        "isExtraImport": true,
        "detail": "configilm",
        "documentation": {}
    },
    {
        "label": "ILMConfiguration",
        "importPath": "configilm.ConfigILM",
        "description": "configilm.ConfigILM",
        "isExtraImport": true,
        "detail": "configilm.ConfigILM",
        "documentation": {}
    },
    {
        "label": "ILMType",
        "importPath": "configilm.ConfigILM",
        "description": "configilm.ConfigILM",
        "isExtraImport": true,
        "detail": "configilm.ConfigILM",
        "documentation": {}
    },
    {
        "label": "NEW_LABELS",
        "importPath": "configilm.extra.BENv2_utils",
        "description": "configilm.extra.BENv2_utils",
        "isExtraImport": true,
        "detail": "configilm.extra.BENv2_utils",
        "documentation": {}
    },
    {
        "label": "LinearWarmupCosineAnnealingLR",
        "importPath": "configilm.extra.CustomTorchClasses",
        "description": "configilm.extra.CustomTorchClasses",
        "isExtraImport": true,
        "detail": "configilm.extra.CustomTorchClasses",
        "documentation": {}
    },
    {
        "label": "get_classification_metric_collection",
        "importPath": "configilm.metrics",
        "description": "configilm.metrics",
        "isExtraImport": true,
        "detail": "configilm.metrics",
        "documentation": {}
    },
    {
        "label": "PyTorchModelHubMixin",
        "importPath": "huggingface_hub",
        "description": "huggingface_hub",
        "isExtraImport": true,
        "detail": "huggingface_hub",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing  ",
        "description": "typing  ",
        "isExtraImport": true,
        "detail": "typing  ",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing  ",
        "description": "typing  ",
        "isExtraImport": true,
        "detail": "typing  ",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "torch.optim",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "torch.optim",
        "description": "torch.optim",
        "detail": "torch.optim",
        "documentation": {}
    },
    {
        "label": "Dataset",
        "importPath": "torch.utils.data",
        "description": "torch.utils.data",
        "isExtraImport": true,
        "detail": "torch.utils.data",
        "documentation": {}
    },
    {
        "label": "DataLoader",
        "importPath": "torch.utils.data",
        "description": "torch.utils.data",
        "isExtraImport": true,
        "detail": "torch.utils.data",
        "documentation": {}
    },
    {
        "label": "random_split",
        "importPath": "torch.utils.data",
        "description": "torch.utils.data",
        "isExtraImport": true,
        "detail": "torch.utils.data",
        "documentation": {}
    },
    {
        "label": "tqdm",
        "importPath": "tqdm.auto",
        "description": "tqdm.auto",
        "isExtraImport": true,
        "detail": "tqdm.auto",
        "documentation": {}
    },
    {
        "label": "tqdm",
        "importPath": "tqdm.auto",
        "description": "tqdm.auto",
        "isExtraImport": true,
        "detail": "tqdm.auto",
        "documentation": {}
    },
    {
        "label": "CNNCfg",
        "importPath": "cnn_yield.resnet_regressor",
        "description": "cnn_yield.resnet_regressor",
        "isExtraImport": true,
        "detail": "cnn_yield.resnet_regressor",
        "documentation": {}
    },
    {
        "label": "ResNetYieldRegressor",
        "importPath": "cnn_yield.resnet_regressor",
        "description": "cnn_yield.resnet_regressor",
        "isExtraImport": true,
        "detail": "cnn_yield.resnet_regressor",
        "documentation": {}
    },
    {
        "label": "ResNetYieldRegressor",
        "importPath": "cnn_yield.resnet_regressor",
        "description": "cnn_yield.resnet_regressor",
        "isExtraImport": true,
        "detail": "cnn_yield.resnet_regressor",
        "documentation": {}
    },
    {
        "label": "CNNCfg",
        "importPath": "cnn_yield.resnet_regressor",
        "description": "cnn_yield.resnet_regressor",
        "isExtraImport": true,
        "detail": "cnn_yield.resnet_regressor",
        "documentation": {}
    },
    {
        "label": "optuna",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "optuna",
        "description": "optuna",
        "detail": "optuna",
        "documentation": {}
    },
    {
        "label": "ViTYieldRegressor",
        "importPath": "vit_yield.vit_regressor",
        "description": "vit_yield.vit_regressor",
        "isExtraImport": true,
        "detail": "vit_yield.vit_regressor",
        "documentation": {}
    },
    {
        "label": "VitConfig",
        "importPath": "vit_yield.vit_regressor",
        "description": "vit_yield.vit_regressor",
        "isExtraImport": true,
        "detail": "vit_yield.vit_regressor",
        "documentation": {}
    },
    {
        "label": "ViTYieldRegressor",
        "importPath": "vit_yield.vit_regressor",
        "description": "vit_yield.vit_regressor",
        "isExtraImport": true,
        "detail": "vit_yield.vit_regressor",
        "documentation": {}
    },
    {
        "label": "VitConfig",
        "importPath": "vit_yield.vit_regressor",
        "description": "vit_yield.vit_regressor",
        "isExtraImport": true,
        "detail": "vit_yield.vit_regressor",
        "documentation": {}
    },
    {
        "label": "compute_metrics",
        "importPath": "metrics",
        "description": "metrics",
        "isExtraImport": true,
        "detail": "metrics",
        "documentation": {}
    },
    {
        "label": "compute_metrics",
        "importPath": "metrics",
        "description": "metrics",
        "isExtraImport": true,
        "detail": "metrics",
        "documentation": {}
    },
    {
        "label": "compute_metrics",
        "importPath": "metrics",
        "description": "metrics",
        "isExtraImport": true,
        "detail": "metrics",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "VisionTransformer",
        "importPath": "timm.models.vision_transformer",
        "description": "timm.models.vision_transformer",
        "isExtraImport": true,
        "detail": "timm.models.vision_transformer",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing ",
        "description": "typing ",
        "isExtraImport": true,
        "detail": "typing ",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing ",
        "description": "typing ",
        "isExtraImport": true,
        "detail": "typing ",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing ",
        "description": "typing ",
        "isExtraImport": true,
        "detail": "typing ",
        "documentation": {}
    },
    {
        "label": "resize",
        "importPath": "skimage.transform",
        "description": "skimage.transform",
        "isExtraImport": true,
        "detail": "skimage.transform",
        "documentation": {}
    },
    {
        "label": "sliding_window_view",
        "importPath": "numpy.lib.stride_tricks",
        "description": "numpy.lib.stride_tricks",
        "isExtraImport": true,
        "detail": "numpy.lib.stride_tricks",
        "documentation": {}
    },
    {
        "label": "mean_absolute_error",
        "importPath": "sklearn.metrics",
        "description": "sklearn.metrics",
        "isExtraImport": true,
        "detail": "sklearn.metrics",
        "documentation": {}
    },
    {
        "label": "mean_squared_error",
        "importPath": "sklearn.metrics",
        "description": "sklearn.metrics",
        "isExtraImport": true,
        "detail": "sklearn.metrics",
        "documentation": {}
    },
    {
        "label": "r2_score",
        "importPath": "sklearn.metrics",
        "description": "sklearn.metrics",
        "isExtraImport": true,
        "detail": "sklearn.metrics",
        "documentation": {}
    },
    {
        "label": "root_mean_squared_error",
        "importPath": "sklearn.metrics",
        "description": "sklearn.metrics",
        "isExtraImport": true,
        "detail": "sklearn.metrics",
        "documentation": {}
    },
    {
        "label": "mean_absolute_error",
        "importPath": "sklearn.metrics",
        "description": "sklearn.metrics",
        "isExtraImport": true,
        "detail": "sklearn.metrics",
        "documentation": {}
    },
    {
        "label": "r2_score",
        "importPath": "sklearn.metrics",
        "description": "sklearn.metrics",
        "isExtraImport": true,
        "detail": "sklearn.metrics",
        "documentation": {}
    },
    {
        "label": "resample",
        "importPath": "sklearn.utils",
        "description": "sklearn.utils",
        "isExtraImport": true,
        "detail": "sklearn.utils",
        "documentation": {}
    },
    {
        "label": "train_test_split",
        "importPath": "sklearn.model_selection",
        "description": "sklearn.model_selection",
        "isExtraImport": true,
        "detail": "sklearn.model_selection",
        "documentation": {}
    },
    {
        "label": "train_test_split",
        "importPath": "sklearn.model_selection",
        "description": "sklearn.model_selection",
        "isExtraImport": true,
        "detail": "sklearn.model_selection",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib    ",
        "description": "pathlib    ",
        "isExtraImport": true,
        "detail": "pathlib    ",
        "documentation": {}
    },
    {
        "label": "argparse,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "argparse.",
        "description": "argparse.",
        "detail": "argparse.",
        "documentation": {}
    },
    {
        "label": "xgboost",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "xgboost",
        "description": "xgboost",
        "detail": "xgboost",
        "documentation": {}
    },
    {
        "label": "get_data_splits",
        "importPath": "data_util         ",
        "description": "data_util         ",
        "isExtraImport": true,
        "detail": "data_util         ",
        "documentation": {}
    },
    {
        "label": "compute_metrics",
        "importPath": "data_util         ",
        "description": "data_util         ",
        "isExtraImport": true,
        "detail": "data_util         ",
        "documentation": {}
    },
    {
        "label": "train_model",
        "importPath": "vit_yield.training",
        "description": "vit_yield.training",
        "isExtraImport": true,
        "detail": "vit_yield.training",
        "documentation": {}
    },
    {
        "label": "tune_hyperparams",
        "importPath": "vit_yield.training",
        "description": "vit_yield.training",
        "isExtraImport": true,
        "detail": "vit_yield.training",
        "documentation": {}
    },
    {
        "label": "tune_resnet_hyperparams",
        "importPath": "vit_yield.training",
        "description": "vit_yield.training",
        "isExtraImport": true,
        "detail": "vit_yield.training",
        "documentation": {}
    },
    {
        "label": "train_xgb",
        "importPath": "xgb_utils",
        "description": "xgb_utils",
        "isExtraImport": true,
        "detail": "xgb_utils",
        "documentation": {}
    },
    {
        "label": "tune_xgb_optuna",
        "importPath": "xgb_utils",
        "description": "xgb_utils",
        "isExtraImport": true,
        "detail": "xgb_utils",
        "documentation": {}
    },
    {
        "label": "train_linear",
        "importPath": "linear_utils",
        "description": "linear_utils",
        "isExtraImport": true,
        "detail": "linear_utils",
        "documentation": {}
    },
    {
        "label": "tune_linear",
        "importPath": "linear_utils",
        "description": "linear_utils",
        "isExtraImport": true,
        "detail": "linear_utils",
        "documentation": {}
    },
    {
        "label": "CNNCfg",
        "kind": 6,
        "importPath": "src.cnn_yield.resnet_regressor",
        "description": "src.cnn_yield.resnet_regressor",
        "peekOfCode": "class CNNCfg:\n    lstm: bool = False\n    lstm_hidden: int = 128\n    lstm_layers: int = 3\n    freeze_backbone: bool = True\n    ckpt: str = \"BIFOLD-BigEarthNetv2-0/resnet101-s2-v0.2.0\"\n    head_hidden: int = 256\n    dropout: float = 0.2\n    @classmethod\n    def from_optuna_trial(cls, trial) -> \"CNNCfg\":",
        "detail": "src.cnn_yield.resnet_regressor",
        "documentation": {}
    },
    {
        "label": "ResNetYieldRegressor",
        "kind": 6,
        "importPath": "src.cnn_yield.resnet_regressor",
        "description": "src.cnn_yield.resnet_regressor",
        "peekOfCode": "class ResNetYieldRegressor(nn.Module):\n    \"\"\"\n    Input  | (B,10,32,32)   or (B,T,10,32,32) if lstm=True\n    Output | (B,) predicted yield\n    \"\"\"\n    def __init__(self, cfg: CNNCfg):\n        super().__init__()\n        self.cfg = cfg\n        self.backbone = self._build_backbone(cfg)\n        self.seq_mode = cfg.lstm",
        "detail": "src.cnn_yield.resnet_regressor",
        "documentation": {}
    },
    {
        "label": "BigEarthNetv2_0_ImageClassifier",
        "kind": 6,
        "importPath": "src.reben_publication.BigEarthNetv2_0_ImageClassifier",
        "description": "src.reben_publication.BigEarthNetv2_0_ImageClassifier",
        "peekOfCode": "class BigEarthNetv2_0_ImageClassifier(pl.LightningModule, PyTorchModelHubMixin):\n    \"\"\"\n    Wrapper around a pytorch module, allowing this module to be used in automatic\n    training with pytorch lightning.\n    Among other things, the wrapper allows us to do automatic training and removes the\n    need to manage data on different devices (e.g. GPU and CPU).\n    Also uses the PyTorchModelHubMixin to allow for easy saving and loading of the model to the Huggingface Hub.\n    \"\"\"\n    def __init__(\n            self,",
        "detail": "src.reben_publication.BigEarthNetv2_0_ImageClassifier",
        "documentation": {}
    },
    {
        "label": "__author__",
        "kind": 5,
        "importPath": "src.reben_publication.BigEarthNetv2_0_ImageClassifier",
        "description": "src.reben_publication.BigEarthNetv2_0_ImageClassifier",
        "peekOfCode": "__author__ = \"Leonard Hackel - BIFOLD/RSiM TU Berlin\"\nclass BigEarthNetv2_0_ImageClassifier(pl.LightningModule, PyTorchModelHubMixin):\n    \"\"\"\n    Wrapper around a pytorch module, allowing this module to be used in automatic\n    training with pytorch lightning.\n    Among other things, the wrapper allows us to do automatic training and removes the\n    need to manage data on different devices (e.g. GPU and CPU).\n    Also uses the PyTorchModelHubMixin to allow for easy saving and loading of the model to the Huggingface Hub.\n    \"\"\"\n    def __init__(",
        "detail": "src.reben_publication.BigEarthNetv2_0_ImageClassifier",
        "documentation": {}
    },
    {
        "label": "PatchDataset",
        "kind": 6,
        "importPath": "src.vit_yield.training",
        "description": "src.vit_yield.training",
        "peekOfCode": "class PatchDataset(Dataset):\n    \"\"\"Holds (X, y) where X is (N,C,H,W) or (N,T,C,H,W).\"\"\"\n    def __init__(self, X: np.ndarray, y: np.ndarray) -> None:\n        self.X = torch.as_tensor(X, dtype=torch.float32)\n        self.y = torch.as_tensor(y, dtype=torch.float32)\n    def __len__(self) -> int: return len(self.X)\n    def __getitem__(self, idx): return self.X[idx], self.y[idx]\n# ──────────────────────────────────────────────────────────────\n#  Training loop\n# ──────────────────────────────────────────────────────────────",
        "detail": "src.vit_yield.training",
        "documentation": {}
    },
    {
        "label": "TrainCfg",
        "kind": 6,
        "importPath": "src.vit_yield.training",
        "description": "src.vit_yield.training",
        "peekOfCode": "class TrainCfg:\n    epochs:    int   = 50\n    lr:        float = 1e-3\n    batch:     int   = 32\n    patience:  int   = 10\n    clip_grad: float = 1.0\ndef train_model(\n    model: nn.Module,\n    train_X: np.ndarray,\n    train_y: np.ndarray,",
        "detail": "src.vit_yield.training",
        "documentation": {}
    },
    {
        "label": "train_model",
        "kind": 2,
        "importPath": "src.vit_yield.training",
        "description": "src.vit_yield.training",
        "peekOfCode": "def train_model(\n    model: nn.Module,\n    train_X: np.ndarray,\n    train_y: np.ndarray,\n    val_X:   np.ndarray,\n    val_y:   np.ndarray,\n    cfg:     TrainCfg = TrainCfg(),\n    device:  str      = \"cuda\",\n) -> Tuple[nn.Module, Dict[str, float]]:\n    dev  = torch.device(device if torch.cuda.is_available() else \"cpu\")",
        "detail": "src.vit_yield.training",
        "documentation": {}
    },
    {
        "label": "tune_hyperparams",
        "kind": 2,
        "importPath": "src.vit_yield.training",
        "description": "src.vit_yield.training",
        "peekOfCode": "def tune_hyperparams(\n    X: np.ndarray,\n    y: np.ndarray,\n    n_trials: int = 20,\n    device:   str = \"cuda\",\n) -> optuna.Study:\n    def objective(trial: optuna.Trial):\n        cfg_vit = VitConfig(\n            lstm=True,\n            lstm_hidden=trial.suggest_int(\"hidden\", 64, 256),",
        "detail": "src.vit_yield.training",
        "documentation": {}
    },
    {
        "label": "tune_resnet_hyperparams",
        "kind": 2,
        "importPath": "src.vit_yield.training",
        "description": "src.vit_yield.training",
        "peekOfCode": "def tune_resnet_hyperparams(\n    X: np.ndarray,\n    y: np.ndarray,\n    n_trials: int = 20,\n    device:   str = \"cuda\",\n) -> optuna.Study:\n    \"\"\"Optuna hyper-parameter tuning for ResNet model.\"\"\"\n    def objective(trial: optuna.Trial):\n        cfg_cnn = CNNCfg.from_optuna_trial(trial)\n        model = ResNetYieldRegressor(cfg_cnn)",
        "detail": "src.vit_yield.training",
        "documentation": {}
    },
    {
        "label": "VitConfig",
        "kind": 6,
        "importPath": "src.vit_yield.vit_regressor",
        "description": "src.vit_yield.vit_regressor",
        "peekOfCode": "class VitConfig:\n    img_size: int = 32\n    in_chans: int = 10\n    patch_size: int = 8\n    lstm: bool = False\n    lstm_hidden: int = 128\n    lstm_layers: int = 3\n    freeze_backbone: bool = True\n    dropout: float = 0.2\n    ckpt: str = \"BIFOLD-BigEarthNetv2-0/vit_base_patch8_224-s2-v0.2.0\"",
        "detail": "src.vit_yield.vit_regressor",
        "documentation": {}
    },
    {
        "label": "ViTYieldRegressor",
        "kind": 6,
        "importPath": "src.vit_yield.vit_regressor",
        "description": "src.vit_yield.vit_regressor",
        "peekOfCode": "class ViTYieldRegressor(nn.Module):\n    \"\"\"Vision-Transformer backbone + optional LSTM head for yield regression.\n    Input shape:\n        * without LSTM –  (B, 10, 32, 32)\n        * with    LSTM –  (B, T, 10, 32, 32)\n    Output: (B, 1) predicted yield.\n    \"\"\"\n    def __init__(self, cfg: VitConfig):\n        super().__init__()\n        self.cfg = cfg",
        "detail": "src.vit_yield.vit_regressor",
        "documentation": {}
    },
    {
        "label": "get_data_splits",
        "kind": 2,
        "importPath": "src.data_util",
        "description": "src.data_util",
        "peekOfCode": "def get_data_splits(\n    df: pd.DataFrame,\n    temp_df: pd.DataFrame | None,\n    root: Path,\n    model: str = \"cnn\",\n    date_range: Tuple[str, str] | None = None,\n) -> List[Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray, str]]:\n    \"\"\"Return LOFO splits for 'cnn', 'cnn_lstm', 'resnet', 'vit', or 'xgb'.\"\"\"\n    if date_range:\n        s, e = date_range",
        "detail": "src.data_util",
        "documentation": {}
    },
    {
        "label": "rmse",
        "kind": 2,
        "importPath": "src.data_util",
        "description": "src.data_util",
        "peekOfCode": "def rmse(y, p): return float(np.sqrt(mean_squared_error(y, p)))\ndef compute_metrics(y_true, y_pred):\n    return dict(rmse=rmse(y_true, y_pred),\n                mae=float(mean_absolute_error(y_true, y_pred)),\n                r2=float(r2_score(y_true, y_pred)))\ndef paired_bootstrap(y, p1, p2, n=1000):\n    idxs  = (resample(np.arange(len(y)), replace=True) for _ in range(n))\n    diff  = [rmse(y[i], p1[i]) - rmse(y[i], p2[i]) for i in idxs]\n    p_val = (np.sum(np.array(diff) > 0) + 1) / (n + 1)\n    return p_val, diff",
        "detail": "src.data_util",
        "documentation": {}
    },
    {
        "label": "compute_metrics",
        "kind": 2,
        "importPath": "src.data_util",
        "description": "src.data_util",
        "peekOfCode": "def compute_metrics(y_true, y_pred):\n    return dict(rmse=rmse(y_true, y_pred),\n                mae=float(mean_absolute_error(y_true, y_pred)),\n                r2=float(r2_score(y_true, y_pred)))\ndef paired_bootstrap(y, p1, p2, n=1000):\n    idxs  = (resample(np.arange(len(y)), replace=True) for _ in range(n))\n    diff  = [rmse(y[i], p1[i]) - rmse(y[i], p2[i]) for i in idxs]\n    p_val = (np.sum(np.array(diff) > 0) + 1) / (n + 1)\n    return p_val, diff\n# ---------------------------------------------------------------------",
        "detail": "src.data_util",
        "documentation": {}
    },
    {
        "label": "paired_bootstrap",
        "kind": 2,
        "importPath": "src.data_util",
        "description": "src.data_util",
        "peekOfCode": "def paired_bootstrap(y, p1, p2, n=1000):\n    idxs  = (resample(np.arange(len(y)), replace=True) for _ in range(n))\n    diff  = [rmse(y[i], p1[i]) - rmse(y[i], p2[i]) for i in idxs]\n    p_val = (np.sum(np.array(diff) > 0) + 1) / (n + 1)\n    return p_val, diff\n# ---------------------------------------------------------------------\n# vegetation-index helper (vectorised, Torch)\n# ---------------------------------------------------------------------\ndef _veg_indices(x: torch.Tensor) -> torch.Tensor:\n    \"\"\"",
        "detail": "src.data_util",
        "documentation": {}
    },
    {
        "label": "_mean_feat",
        "kind": 5,
        "importPath": "src.data_util",
        "description": "src.data_util",
        "peekOfCode": "_mean_feat = lambda s: (\n    np.hstack([m := s.mean((2, 3)).reshape(-1, BANDS),          # bands\n               np.apply_along_axis(_indices, 1, m)])            # + 5 indices\n    if s.size else np.empty((0, BANDS + 5))\n)\n# ─────────── branch builders (clean & reusable) ──────────────\ndef _make_lstm_split(others, X_te, y_te):\n    Tmax = max((v[0].shape[1] for v in others), default=0)\n    Xtr  = np.concatenate([_pad_seq(v[0], Tmax) for v in others], axis=0) \\\n           if others else np.empty((0, 0, BANDS, PATCH, PATCH))",
        "detail": "src.data_util",
        "documentation": {}
    },
    {
        "label": "LinearReg",
        "kind": 6,
        "importPath": "src.linear_utils",
        "description": "src.linear_utils",
        "peekOfCode": "class LinearReg(torch.nn.Module):\n    def __init__(self, d_in: int):       # y = Wx + b\n        super().__init__()\n        self.linear = torch.nn.Linear(d_in, 1)\n    def forward(self, x):                # (B,d) → (B,1)\n        return self.linear(x).squeeze(1)\n# ────────────── single-run training ───────────\ndef train_linear(\n    X_tr: np.ndarray, y_tr: np.ndarray,\n    X_va: np.ndarray, y_va: np.ndarray,",
        "detail": "src.linear_utils",
        "documentation": {}
    },
    {
        "label": "train_linear",
        "kind": 2,
        "importPath": "src.linear_utils",
        "description": "src.linear_utils",
        "peekOfCode": "def train_linear(\n    X_tr: np.ndarray, y_tr: np.ndarray,\n    X_va: np.ndarray, y_va: np.ndarray,\n    lr: float = 1e-3,\n    wd: float = 0.0,\n    epochs: int = 200,\n    patience: int = 25,\n    device: str | torch.device | None = None,\n):\n    dev   = torch.device(device or (\"cuda\" if torch.cuda.is_available() else \"cpu\"))",
        "detail": "src.linear_utils",
        "documentation": {}
    },
    {
        "label": "tune_linear",
        "kind": 2,
        "importPath": "src.linear_utils",
        "description": "src.linear_utils",
        "peekOfCode": "def tune_linear(\n    X: np.ndarray, y: np.ndarray,\n    n_trials: int = 40,\n    seed: int = 42,\n):\n    X_tr, X_va, y_tr, y_va = train_test_split(\n        X, y, test_size=0.2, random_state=seed)\n    def obj(trial: optuna.Trial):\n        params = dict(\n            lr = trial.suggest_float(\"lr\", 1e-4, 1e-2, log=True),",
        "detail": "src.linear_utils",
        "documentation": {}
    },
    {
        "label": "CLIConfig",
        "kind": 6,
        "importPath": "src.main",
        "description": "src.main",
        "peekOfCode": "class CLIConfig:\n    model:        str\n    tune:         bool = False\n    csv:          Path = Path(\"/home/matthew/Projects/comparative-yield-models/Yield_GEE_S2_ByField/field_images_grouped.csv\")\n    data_root:    Path = Path(\"/home/matthew/Projects/comparative-yield-models/\")\n    temp_csv:     Path = Path(\"/home/matthew/Projects/comparative-yield-models/Yield_GEE_TEMP_ByField/field_temps.csv\")\n    soil_root:    Path = Path(\"/home/matthew/Projects/comparative-yield-models/Yield_GEE_SoilOrg/\")\n    device:       str  = \"cuda\"   # add a quick switch for CPU timing\n# ─────────────────────────────────────────────────────────────\n# 2│ Argument-parser that builds CLIConfig",
        "detail": "src.main",
        "documentation": {}
    },
    {
        "label": "avg_infer_time_ms",
        "kind": 2,
        "importPath": "src.main",
        "description": "src.main",
        "peekOfCode": "def avg_infer_time_ms(model, X_val: np.ndarray, *, device: str = \"cuda\", batch: int = 64) -> float:\n    \"\"\"Return mean milliseconds per sample for forward passes on *X_val*.\n    Handles PyTorch modules and XGBoost Booster objects.  The caller must\n    ensure the model is already on the desired device.\n    \"\"\"\n    n = len(X_val)\n    # ── XGBoost (CPU‑only) ───────────────────────────────\n    if isinstance(model, xgb.Booster):\n        dm = xgb.DMatrix(X_val)\n        t0 = time.perf_counter()",
        "detail": "src.main",
        "documentation": {}
    },
    {
        "label": "parse_args",
        "kind": 2,
        "importPath": "src.main",
        "description": "src.main",
        "peekOfCode": "def parse_args() -> CLIConfig:\n    parser = argparse.ArgumentParser(\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n        description=textwrap.dedent(\n            \"\"\"\\\n            Train a single model (optionally with Optuna tuning) on all\n            leave‑one‑field‑out splits, report per‑fold metrics **and**\n            average inference time (ms per sample).\n            \"\"\"),\n    )",
        "detail": "src.main",
        "documentation": {}
    },
    {
        "label": "build_and_train",
        "kind": 2,
        "importPath": "src.main",
        "description": "src.main",
        "peekOfCode": "def build_and_train(cfg: CLIConfig,\n                    X_tr: np.ndarray, y_tr: np.ndarray,\n                    X_va: np.ndarray, y_va: np.ndarray):\n    \"\"\"Return trained model + metrics dict (RMSE, MAE, R²).\"\"\"\n    # ---------- Vision‑Transformer family ----------\n    if cfg.model in {\"vit\", \"vit_lstm\"}:\n        vit_cfg = VitConfig(lstm=cfg.model == \"vit_lstm\")\n        if cfg.tune and cfg.model == \"vit_lstm\":\n            best = tune_hyperparams(X_tr, y_tr, 20)\n            vit_cfg = VitConfig(lstm_hidden=best.params[\"hidden\"],",
        "detail": "src.main",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "src.main",
        "description": "src.main",
        "peekOfCode": "def main() -> None:\n    cfg = parse_args()\n    logging.basicConfig(\n        level=logging.INFO,\n        format=\"%(asctime)s | %(levelname)-8s | %(message)s\",\n        datefmt=\"%H:%M:%S\",\n    )\n    logging.info(\"Reading CSV and building LOFO splits …\")\n    temp_df = pd.read_csv(cfg.temp_csv)\n    images_df      = pd.read_csv(cfg.csv)",
        "detail": "src.main",
        "documentation": {}
    },
    {
        "label": "compute_metrics",
        "kind": 2,
        "importPath": "src.metrics",
        "description": "src.metrics",
        "peekOfCode": "def compute_metrics(y_true: np.ndarray, y_pred: np.ndarray) -> Dict[str, float]:\n    \"\"\"Return RMSE, MAE and R² in one dict (ready for DataFrame()).\"\"\"\n    rmse = root_mean_squared_error(y_true, y_pred)\n    mae  = mean_absolute_error(y_true, y_pred)\n    r2   = r2_score(y_true, y_pred)\n    return {\"rmse\": rmse, \"mae\": mae, \"r2\": r2}",
        "detail": "src.metrics",
        "documentation": {}
    },
    {
        "label": "train_xgb",
        "kind": 2,
        "importPath": "src.xgb_utils",
        "description": "src.xgb_utils",
        "peekOfCode": "def train_xgb(\n    X_train: np.ndarray,\n    y_train: np.ndarray,\n    X_val:   np.ndarray,\n    y_val:   np.ndarray,\n    params:  dict | None = None,\n    early:   int  = 80,                # ≈10 % of default 800 trees\n):\n    \"\"\"Train XGBoost regressor with early stopping; returns (model, metrics).\"\"\"\n    prm = BASE_PARAMS | (params or {})",
        "detail": "src.xgb_utils",
        "documentation": {}
    },
    {
        "label": "tune_xgb_optuna",
        "kind": 2,
        "importPath": "src.xgb_utils",
        "description": "src.xgb_utils",
        "peekOfCode": "def tune_xgb_optuna(\n    X: np.ndarray,\n    y: np.ndarray,\n    n_trials: int = 50,\n    seed: int = 42,\n):\n    \"\"\"Optuna Bayesian search; returns best param-dict merged into BASE_PARAMS.\"\"\"\n    X_tr, X_val, y_tr, y_val = train_test_split(X, y, test_size=0.2, random_state=seed)\n    def objective(trial: optuna.Trial) -> float:\n        prm = {",
        "detail": "src.xgb_utils",
        "documentation": {}
    },
    {
        "label": "BASE_PARAMS",
        "kind": 5,
        "importPath": "src.xgb_utils",
        "description": "src.xgb_utils",
        "peekOfCode": "BASE_PARAMS = dict(\n    objective=\"reg:squarederror\",\n    eval_metric=\"rmse\",\n    tree_method= \"hist\",#\"gpu_hist\" if _gpu_available() else \"hist\",\n    learning_rate=0.05,\n    max_depth=6,\n    subsample=0.8,\n    colsample_bytree=0.8,\n    n_estimators=800,\n)",
        "detail": "src.xgb_utils",
        "documentation": {}
    }
]